"""
Copyright (C) 2024 André Ourednik and Contributors

Permission is hereby granted to use this script for any purpose, including preparing production-ready documents, provided the following conditions are met:

1. You may not redistribute or sell this script or any derived software based on this script, in part or in whole, for commercial purposes without prior written permission from the original author, André Ourednik.

2. Redistribution of this script, with or without modifications, must retain this copyright notice and terms. Modifications must include a notice identifying the contributing authors and a summary of the changes made.

3. Contributors grant joint copyright ownership of their contributions to the original author (André Ourednik), ensuring that this script and all derived works remain under these terms.

4. Non-Liability: This script is provided "as is," without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose, or non-infringement. In no event shall the authors or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the script or the use or other dealings in the script.

This license does not restrict the use of outputs or products generated by this script, provided the script itself is not redistributed or sold.

Author: André Ourednik
Contributors: [Add your name here if you contribute to this script]
"""

import os
import sys
import argparse
import yaml
import zipfile
import shutil
import fitz  # PyMuPDF package for PDF processing
from PIL import Image # pillow package
import io
import json
import base64
from datetime import datetime



parser = argparse.ArgumentParser(description="Convert PDF to fixed-layout EPUB, conserving the table of contents, inner cross-references and hyperlinks.")
parser.add_argument("--pdf_path", type=str, help="Path to the sourcePDF file")
parser.add_argument("--output_folder", type=str, help="Folder into which the resulting EPUB will be written")
parser.add_argument("--title", type=str, help="Book title")
parser.add_argument("--epub_file_name", type=str, help="Name of the EPUB file, without extension")
parser.add_argument("--author", type=str, help="Book author")
parser.add_argument("--language", type=str, help="Main book lnaguage")
parser.add_argument("--publisher", type=str, help="Book publisher")
parser.add_argument("--date", type=str, help="Publication date of the book")
parser.add_argument("--description", type=str, help="Book description")
parser.add_argument("--rights", type=str, help="Rights information of your PDF book")
parser.add_argument("--font_folder", type=str, help="Folder containing fonts")
parser.add_argument("--css_folder", type=str, help="Folder containing the css file")
parser.add_argument("--cover_image", type=str, help="Path to the cover image")
parser.add_argument("--urn", type=str, help="URN of the PDF file")
parser.add_argument("--yaml_config", type=str, help="Path to the YAML configuration file")

args = parser.parse_args()

# Initialize variables with command-line arguments or defaults
pdf_path = args.pdf_path
output_folder = args.output_folder
title = args.title
epub_file_name = args.epub_file_name
author = args.author
language = args.language
publisher = args.publisher
date = args.date
description = args.description
rights = args.rights
font_folder = args.font_folder
css_folder = args.css_folder
cover_image = args.cover_image
urn = args.urn

# Default values
defaults = {
    'output_folder' : "output",
    'title': "Default Title",
    'author': "Unknown Author",
    'language': "en",
    'publisher': "Unknown Publisher",
    'date': "2025-01-01",
    'description': "No Description",
    'rights': "All Rights Reserved",
    'font_folder': "font",
    'css_folder': "css",
    'cover_image': "",
    'urn': "urn:1234567890"
}
no_pdf_message = "A PDF filename is required and must be provided either as first argument (pdf2epub3fixed.py --pdf_path your_file.pdf) or in the YAML configuration file."

# Fallback to YAML values if yaml_cofig is defined, and if values not provided in command-line arguments, and to defaults if not privided in the yaml file
if args.yaml_config and os.path.isfile(args.yaml_config):
    print(f"Reading configuration file {args.yaml_config}. Parameters unspecified in the command line will be read from {args.yaml_config} whenever available")
    yaml_file = args.yaml_config
elif args.yaml_config and not os.path.isfile(args.yaml_config) :
    raise FileNotFoundError(f"The configuration file {args.yaml_config} does not exist.")
elif os.path.isfile("config.yml") :
    print("No configuration file specified in the parameters, but config.yml found. Parameters unspecified in the command line will be read from config.yml whenever available.")
    yaml_file = "config.yml"
else : yaml_file = None

if yaml_file is not None :
    with open(yaml_file, 'r') as file:
        yaml_config = yaml.safe_load(file)
    pdf_path = args.pdf_path if args.title else yaml_config.get('pdf_path')
    if not pdf_path:
            raise ValueError(no_pdf_message)
    output_folder = args.output_folder if args.output_folder else yaml_config.get('output_folder', defaults['output_folder'])
    title = args.title if args.title else yaml_config.get('title', defaults['title'])
    epub_file_name = args.epub_file_name if args.epub_file_name else yaml_config.get('epub_file_name', os.path.splitext(pdf_path)[0])
    author = args.author if args.author else yaml_config.get('author', defaults['author'])
    language = args.language if args.language else yaml_config.get('language', defaults['language'])
    publisher = args.publisher if args.publisher else yaml_config.get('publisher', defaults['publisher'])
    date = args.date if args.date else yaml_config.get('date', defaults['date'])
    description = args.description if args.description else yaml_config.get('description', defaults['description'])
    rights = args.rights if args.rights else yaml_config.get('rights', defaults['rights'])
    font_folder = args.font_folder if args.font_folder else yaml_config.get('font_folder', defaults['font_folder'])
    css_folder = args.css_folder if args.css_folder else yaml_config.get('css_folder', defaults['css_folder'])
    cover_image = args.cover_image if args.cover_image else yaml_config.get('cover_image', defaults['cover_image'])
    urn = args.urn if args.urn else yaml_config.get('urn', defaults['urn'])
else :
    # Fallback to default values if even YAML config is not provided
    if not pdf_path:
        raise ValueError(no_pdf_message)
    output_folder = output_folder if output_folder else defaults['output_folder']
    title = title if title else defaults['title']
    epub_file_name = epub_file_name if epub_file_name else os.path.splitext(pdf_path)[0]
    author = author if author else defaults['author']
    language = language if language else defaults['language']
    publisher = publisher if publisher else defaults['publisher']
    date = date if date else defaults['date']
    description = description if description else defaults['description']
    rights = rights if rights else defaults['rights']
    font_folder = font_folder if font_folder else defaults['font_folder']
    css_folder = css_folder if css_folder else defaults['css_folder']
    cover_image = cover_image if cover_image else defaults['cover_image']

output_folder_html = os.path.join(output_folder,epub_file_name + "_html")
output_folder_pageimages = os.path.join(output_folder,epub_file_name + "_pageimages")
epub_file_path = os.path.join(output_folder,epub_file_name + "_html.epub")
epub_file_path_pageimages = os.path.join(output_folder,epub_file_name + "_pageimages.epub")

def write_mimetype_file(output_folder):
    mimetype_path = os.path.join(output_folder, "mimetype")
    with open(mimetype_path, "w", encoding="utf-8") as f:
        f.write("application/epub+zip")

def generate_font_list(folder_path):
    font_array = []
    for file_name in os.listdir(folder_path):
        if file_name.endswith((".ttf", ".otf")):  # Check if the file is a TrueType font
            font_name = os.path.splitext(file_name)[0]  # Remove the '.ttf' extension
            font_path = os.path.join(folder_path, file_name)
            font_array.append({
                "font_name": font_name,
                "font_path": font_path
            })
    return font_array

font_list = generate_font_list(font_folder)
fonts_in_pdf = []

def write_meta_inf_container_xml(meta_inf_folder):
    """Write the META-INF/container.xml file"""
    container_path = os.path.join(meta_inf_folder, "container.xml")
    container_content = """<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
    <rootfiles>
        <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
    </rootfiles>
</container>
"""
    with open(container_path, "w", encoding="utf-8") as f:
        f.write(container_content)

def write_content_opf(oebps_folder,content_opf_items,page_html_files,variant):
    """Write OEBPS/content.opf"""
    content_opf_path = os.path.join(oebps_folder, "content.opf")
    font_items = ""
    if variant == "html" :
        for font in font_list:
            media_type = "application/x-font-ttf"  # Default for .ttf
            if font["font_path"].lower().endswith(".otf"):
                media_type = "application/vnd.ms-opentype"  # Correct media type for .otf
            font_items += f'<item id="{font["font_name"]}" href="{font["font_path"]}" media-type="{media_type}"/>\n'    
    content_opf_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<package version="3.0" xmlns="http://www.idpf.org/2007/opf" unique-identifier="bookid" prefix="rendition: http://www.idpf.org/vocab/rendition/# ibooks: http://vocabulary.itunes.apple.com/rdf/ibooks/vocabulary-extensions-1.0/">
    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
        <meta name="generator" content="pdf2epub3fixed" />
        <meta property="ibooks:specified-fonts">true</meta>
        <dc:title>{title}</dc:title>
        <dc:creator id="creator">{author}</dc:creator>
        <meta refines="#creator" property="role" scheme="marc:relators">aut</meta>
        <dc:language>{language}</dc:language>
        <dc:publisher>{publisher}</dc:publisher>
        <dc:date>{date}</dc:date>
        <dc:description>{description}</dc:description>
        <dc:rights>{rights}</dc:rights>
        <dc:identifier id="bookid">urn:uuid:{urn}</dc:identifier>
        <meta name="cover" content="book-cover" />
        <meta property="dcterms:modified">{datetime.now().strftime('%Y-%m-%dT%H:%M:%SZ')}</meta>
        <!--fixed-layout options-->
		<meta property="rendition:layout">pre-paginated</meta>
		<meta property="rendition:orientation">portrait</meta>
		<meta property="rendition:spread">none</meta>
    </metadata>
    <manifest>
        <item id="toc" href="toc.ncx" media-type="application/x-dtbncx+xml"/>
        <item id="nav" href="toc.xhtml" media-type="application/xhtml+xml" properties="nav"/>
        <item id="css" href="{css_folder}/style.css" media-type="text/css"/>
        {font_items}
        {"".join(content_opf_items)}
    </manifest>
    <spine toc="toc">
        {"".join(page_html_files)}
    </spine>
</package>
"""
    with open(content_opf_path, "w", encoding="utf-8") as f:
        f.write(content_opf_content)


def write_toc_xhtml(oebps_folder, doc):
    """This generates an EPUB 3 type navigation."""
    toc_xhtml_path = os.path.join(oebps_folder, "toc.xhtml")
    toc = doc.get_toc() # [[1, 'Préface', 7], [1, 'Les deux mélodies fondamentales', 17], ...]
    toc_xhtml_points = []
    for chapnum, t in enumerate(toc) :
        toc_xhtml_points.append(f"""
        <li><a href="page_{t[2]}.xhtml">{t[1]}</a></li>
        """)
    toc_xhtml_content = f"""<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <title>{title}</title>
    </head>
    <body>
        <nav epub:type="toc" id="toc">
            <h1>Table of Contents</h1>
            <ol>
                {"".join(toc_xhtml_points)}
            </ol>
        </nav>
    </body>
</html>
"""
    with open(toc_xhtml_path, "w", encoding="utf-8") as f:
        f.write(toc_xhtml_content)


def write_toc_ncx(oebps_folder, doc):
    """This generates an EPUB 2 type navigation. Depracated."""
    toc_ncx_path = os.path.join(oebps_folder, "toc.ncx")
    toc = doc.get_toc() # [[1, 'Préface', 7], [1, 'Les deux mélodies fondamentales', 17], ...]
    toc_ncx_points = []
    for chapnum, t in enumerate(toc) :
        toc_ncx_points.append(f"""
        <navPoint id="chapter-{chapnum + 1}" playOrder="{chapnum + 1}">
            <navLabel>
                <text>{t[1]}</text>
            </navLabel>
            <content src="page_{t[2]}.xhtml"/>
        </navPoint>
        """)
    toc_ncx_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
    <head>
        <meta name="dtb:uid" content="urn:uuid:12345678-1234-1234-1234-123456789abc"/>
        <meta name="dtb:depth" content="1"/>
        <meta name="dtb:totalPageCount" content="{doc.page_count}"/>
        <meta name="dtb:maxPageNumber" content="{doc.page_count}"/>
    </head>
    <docTitle>
        <text>{title}</text>
    </docTitle>
    <navMap>
        {"".join(toc_ncx_points)}
    </navMap>
</ncx>
"""
    with open(toc_ncx_path, "w", encoding="utf-8") as f:
        f.write(toc_ncx_content)

def write_css_and_font_files(oebps_folder,font_folder_output,variant):
        # Step 8: Add a CSS file with @font-face
    css_folder = os.path.join(oebps_folder, "css")
    os.makedirs(css_folder, exist_ok=True)  # Create the 'css' folder if it doesn't exist
    css_path = os.path.join(css_folder, "style.css")
    css_content = ""
    if variant == "html" :
        for font in font_list :
            original_extension = os.path.splitext(font['font_path'])[1]
            output_filename_css = f"{font['font_name']}{original_extension}" # Path in CSS
            css_content += f"""@font-face {{
        font-family: \"{font['font_name']}\";
        font-style: normal;
        font-weight: normal;
        src: url(\"../font/{output_filename_css}\");
    }}"""
    css_content += """body, div, dl, dt, dd, h1, h2, h3, h4, h5, h6, p, pre, code, blockquote, figure {
	margin:0;
	padding:0;
	border-width:0;
	text-rendering:optimizeSpeed;
}
div { position: absolute; }
img { position: absolute; }
"""
    with open(css_path, "w", encoding="utf-8") as f:
        f.write(css_content)
    if variant == "html" :
        for font in font_list : 
            original_extension = os.path.splitext(font['font_path'])[1]  # Get the original extension (.ttf or .otf)
            output_filename = f"{font['font_name']}{original_extension}"
            font_path_output = os.path.join(font_folder_output, output_filename)
            shutil.copyfile(font['font_path'], font_path_output)

def extract_crosslinks(page):
    """Extract crosslinks using page.get_links() and add them to JSON"""
    links = []
    for link in page.get_links():
        rect = link.get('from')
        point = link.get('to')
        links.append({
            "kind" : link.get('kind'), 
            "xref" : link.get('xref'),  
            "uri" : link.get('uri'),
            "nameddest": link.get('nameddest'),
            "id" : link.get('id'),
            "zoom" : link.get('zoom'),
            "page" : link.get('page'),
            "to" : [point.x, point.y] if point else None,
            "rect": [rect.x0, rect.y0, rect.x1, rect.y1] if rect else None
        })
    return links
    

def extract_pdf_to_json(doc, output_json_path):
    """Extracts all pages of a PDF as JSON and writes to a file."""
    pages_data = []
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        page_dict = page.get_text("dict")  # Extract page data in dict format        
        # Process blocks to handle binary data
        for block in page_dict.get("blocks", []):
            if "image" in block and isinstance(block["image"], bytes):
                # Convert image bytes to base64 string
                block["image"] = base64.b64encode(block["image"]).decode("utf-8")
        crosslinks = extract_crosslinks(page)  
        page_data = {
            "page_num": page_num + 1,  # Human-readable page number
            "content": page_dict,
            "crosslinks": crosslinks
        }
        pages_data.append(page_data)
    with open(output_json_path, "w", encoding="utf-8") as json_file:
        json.dump(pages_data, json_file, indent=4, ensure_ascii=False)
    print(f"PDF content extracted and saved to {output_json_path}")

def create_epub_structure_from_pdf(pdf_path, output_folder, variant, generate_json = True):    
    """Creates the folder structure and files needed for a fixed-layout EPUB from a PDF. Depending on the variant, generate a HTML based version with selectable texte or a version consisting of image renderings of the PDF"""
    os.makedirs(output_folder, exist_ok=True)
    meta_inf_folder = os.path.join(output_folder, "META-INF")
    os.makedirs(meta_inf_folder, exist_ok=True)
    oebps_folder = os.path.join(output_folder, "OEBPS")
    os.makedirs(oebps_folder, exist_ok=True)
    if variant == "html" : 
        font_folder_output = os.path.join(oebps_folder, "font")
        os.makedirs(font_folder_output, exist_ok=True)
    else: 
        font_folder_output = ""
    images_folder = os.path.join(oebps_folder, "image")
    os.makedirs(images_folder, exist_ok=True)
    write_mimetype_file(output_folder)
    write_meta_inf_container_xml(meta_inf_folder)

    # Initialize content.opf and toc.ncx content
    content_opf_items = []
    page_html_files = []

    # Loop through PDF pages and generate HTML
    doc = fitz.open(pdf_path)
    if generate_json : 
        print("Extracting the PDF structure as raw JSON data for verification")
        extract_pdf_to_json(
            doc,
            os.path.join(output_folder, epub_file_name + "_rawstructure.json")
        )
    image_counter = 0
    print("processing pages: ")
    for page_num in range(doc.page_count):
        print(str(page_num), end="\r")
        print(str(page_num), end=" ")
        page = doc.load_page(page_num)
        html_file_name = f"page_{page_num + 1}.xhtml"
        html_file_path = os.path.join(oebps_folder, html_file_name)
        # Generate fixed-layout HTML for the page
        if variant == "html" :
            page_html, image_counter, image_manifest = generate_fixed_layout_html_selectable(
                page, page_num, images_folder, image_counter
            )
        else :
            page_html, image_counter, image_manifest = generate_fixed_layout_html(
                page, page_num, images_folder, image_counter
            )
        with open(html_file_path, "w", encoding="utf-8") as f:
            f.write(page_html)
        # Add to manifest and toc
        content_opf_items.append(
            f'<item id="page_{page_num + 1}" href="{html_file_name}" media-type="application/xhtml+xml"/>\n'
        )
        for img in image_manifest:
            content_opf_items.append(
                f'<item id="page_{img["id"]}" href="{img["href"]}" media-type="application/xhtml+xml"/>\n'
            )
        page_html_files.append(f'<itemref idref="page_{page_num + 1}"/>\n')
    print("pages processed.")

    # Add a cover image if available  
    if os.path.exists(cover_image) :
        print("Processing cover image")
        cover_image_destination = os.path.join(images_folder, cover_image)
        shutil.copy2(cover_image, cover_image_destination)
        content_opf_items.append(
                f'<item id="book-cover" href="image/{cover_image}" media-type="image/png"/>\n'
            )
    else : print("Your book has no cover image.")

    if variant == "html":
        print("Verify if you have all the fonts actually used in the PDF. Add them if necessary, using these exact names:")
        for fnt in fonts_in_pdf:
            print(fnt)
    write_content_opf(oebps_folder,content_opf_items,page_html_files,variant)
    write_toc_xhtml(oebps_folder, doc)
    write_toc_ncx(oebps_folder, doc)
    write_css_and_font_files(oebps_folder,font_folder_output,variant)
    print(f"EPUB structure created at: {output_folder}")

def process_red_boxes_links(frompage, html_content):
    """Extracts red boxes with links and adds them as cross-references in HTML."""
    for link in frompage.get_links():
        rect = link.get('from')
        # point = link.get('to')
        topage = link.get('page')
        # kind = link.get('kind') 
        # xref = link.get('xref')  
        uri = link.get('uri')
        # nameddest = link.get('nameddest')
        # id = link.get('id')
        # zoom = link.get('zoom')
        # to = [point.x, point.y] if point else None,
        width = rect.x1 - rect.x0
        height = rect.y1 - rect.y0
        if topage is not None:
            html_content += f'<a href="page_{topage + 1}.xhtml" style="position:absolute; left:{rect.x0}px; top:{rect.y0}px; width:{width}px; height:{height}px; border:0.3px solid blue; display:block; "></a>\n'
        elif uri is not None :
            html_content += f'<a href="{uri}" style="position:absolute; left:{rect.x0}px; top:{rect.y0}px; width:{width}px; height:{height}px; border:0.3px solid blue; display:block; "></a>\n' 
    return html_content

def is_all_caps(text):
  """
  Checks if the given text is entirely in uppercase. There is no way to extract smallcaps status from pdf, so using this as fallback 
  """
  for char in text:
    if not char.isalpha() or not char.isupper() or char in ["."," ",","]:
      return False
  return True

def generate_fixed_layout_html(page, page_num, images_folder, image_counter, dpi=300):
    """
    Generates fixed-layout HTML for a single PDF page by rendering the page as an image.
    """
    html_content = f"""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width={page.rect.width},height={page.rect.height}" />
    <title>Page {page_num + 1}</title>
    <link rel="stylesheet" type="text/css" href="css/style.css" />
</head>
<body style="width:{page.rect.width}px;height:{page.rect.height}px; position:relative;">
"""

    # Render the PDF page as an image
    pix = page.get_pixmap(dpi=dpi)
    image_filename = f"page_{page_num + 1}.png"
    image_path = os.path.join(images_folder, image_filename)
    pix.save(image_path)

    # Add the rendered page image to the HTML content
    html_content += f"""<img src="image/{image_filename}" style="position:absolute; left:0px; top:0px; width:{page.rect.width}px; height:{page.rect.height}px;" />\n"""

    html_content = process_red_boxes_links(page, html_content)
    html_content += "</body></html>"

    # Update image manifest
    image_manifest = [{
        'id': f"image_{image_counter}",
        'href': f"image/{image_filename}"
    }]
    image_counter += 1

    return html_content, image_counter, image_manifest


def generate_fixed_layout_html_selectable(page, page_num, images_folder, image_counter):
    """Generates fixed-layout HTML for a single PDF page, including images. Using get_text("dict") and get_text("words"). Is difficult to make work, because the word splitting and the span splitting inside words sometimes overlap"""
    html_content = f"""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width={page.rect.width},height={page.rect.height}" />
    <title>Page {page_num + 1}</title>
    <link rel="stylesheet" type="text/css" href="css/style.css" />
</head>
<body style="width:{page.rect.width}px;height:{page.rect.height}px; position:relative;">
"""  
    text_instances = page.get_text("rawdict")  # Extract layout-based text

    # Extract words and their bounding boxes
    if "blocks" in text_instances:
        for block_no, block in enumerate(text_instances["blocks"]):
            if "lines" in block:
                for line_no, line in enumerate(block["lines"]):
                    for span in line["spans"]:
                        font_name = span["font"]
                        if font_name not in fonts_in_pdf:
                            fonts_in_pdf.append(font_name)
                        font_size = span["size"]
                        words = []
                        current_word = ""
                        first_letter_start_x = None
                        first_letter_start_y = None
                        for char_data in span['chars']:
                            char = char_data['c'] # {'origin': (80.331, 222.817), 'bbox': (80.3, 213.5, 86.6, 225.3), 'c': 'A'}, 
                            if char != ' ' :
                                if not current_word:  # If the word is empty, i.e. new, start of a new word delimiter
                                    first_letter_start_x = char_data['bbox'][0]
                                    first_letter_start_y = char_data['bbox'][1]
                                current_word += char
                            else :
                                if current_word:  # Since the new character is a space, we can add the current word to the list of words
                                    last_letter_end_x = char_data['bbox'][2]
                                    last_letter_end_y = char_data['bbox'][3]
                                    words.append({
                                        'word': current_word, 
                                        'bbox': (first_letter_start_x, first_letter_start_y, last_letter_end_x, last_letter_end_y)
                                    })
                                    current_word = ""
                                    first_letter_start_x = None
                                    first_letter_start_y = None
                                    words.append({'word': ' ', 'bbox': char_data['bbox']}) # Add space as a word
                        # Add the last word if there is any
                        if current_word:
                            last_letter_end_x = char_data['bbox'][2]
                            last_letter_end_y = char_data['bbox'][3]
                            words.append({
                                'word': current_word, 'bbox': (first_letter_start_x, first_letter_start_y, last_letter_end_x, last_letter_end_y)
                            })
                        # span_x0, span_y0, span_x1, span_y1 = span["bbox"]
                        for word in words :
                            word_text = word['word']
                            x0, y0, x1, y1 = word['bbox']
                            width = x1 - x0
                            height = y1 - y0
                            word_text = word_text.replace('&', '&amp;').replace(u'\u00A0', '&nbsp;')
                            '''
                            if len(word_text) > 1 and page_num > 353 :
                                if is_all_caps(word_text):
                                    word_text = f"<span style='font-variant:small-caps'>{word_text[0] + word_text[1:].lower()}</span>"
                                    print(word_text) 
                            '''
                            html_content += f"""<div style="position:absolute; left:{x0}px; top:{y0}px; width:{width}px; height:{height}px; font-family:'{font_name}'; font-size:{font_size}px; white-space:nowrap;">{word_text}</div>\n"""
    html_content, image_manifest, image_counter = process_images(text_instances, images_folder, image_counter, html_content)
    html_content += process_vector_drawings(page)
    html_content = process_red_boxes_links(page, html_content)
    html_content += "</body></html>"
    return html_content, image_counter, image_manifest

def process_images(text_instances, images_folder, image_counter, html_content) :
    """Process images on the page and prepare the listing of images in the manifest. Only used in compelx HTML layout"""
    image_manifest= []
    if 'blocks' in text_instances:
        for block in text_instances['blocks']:
            if 'image' in block :
                if isinstance(block['image'], bytes):
                    # Extract and save image
                    image_data = block['image']
                    image = Image.open(io.BytesIO(image_data))
                    image_filename = f"image_{image_counter}.png"
                    image_path = os.path.join(images_folder, image_filename)
                    image.save(image_path, format="PNG")
                    # Add the image to the manifest
                    image_manifest.append({
                        'id': f"image_{image_counter}",
                        'href': f"image/{image_filename}"
                    })
                    # Get image position and dimensions
                    x0, y0, x1, y1 = block['bbox']
                    width = x1 - x0
                    height = y1 - y0
                    html_content += f'<figure id="_image_{image_counter}"><img src="image/{image_filename}" style="left:{x0}px; top:{y0}px; width:{width}px; height:{height}px;" />\n</figure>'
                    image_counter += 1
                else:
                    continue  # Skip unsupported image formats
    return html_content, image_manifest, image_counter 

def process_vector_drawings(page) :
    vectors = page.get_drawings()
    svg_content = ""
    if len(vectors) > 0 :
        svg_elements = []
        for item in vectors:
            if item['type'] == 's':  # Assuming 's' stands for stroke or line
                for action, *points in item['items']:
                    if action == 'l':  # Assuming 'l' stands for line
                        start_point, end_point = points
                        x1, y1 = start_point.x, start_point.y
                        x2, y2 = end_point.x, end_point.y
                        stroke_color = f"rgb({int(item['color'][0] * 255)}, {int(item['color'][1] * 255)}, {int(item['color'][2] * 255)})"
                        stroke_width = item['width']
                        stroke_opacity = item['stroke_opacity']

                        line_element = f'''
                        <line x1="{x1}" y1="{y1}" x2="{x2}" y2="{y2}"
                            stroke="{stroke_color}"
                            stroke-width="{stroke_width}"
                            stroke-opacity="{stroke_opacity}" />
                        '''
                        svg_elements.append(line_element)

            elif item['type'] == 'r':  # Assuming 'r' stands for rectangle
                x, y, width, height = item['rect'].x, item['rect'].y, item['rect'].width, item['rect'].height
                stroke_color = f"rgb({int(item['color'][0] * 255)}, {int(item['color'][1] * 255)}, {int(item['color'][2] * 255)})"
                stroke_width = item['width']
                stroke_opacity = item['stroke_opacity']
                fill_color = f"rgb({int(item['fill'][0] * 255)}, {int(item['fill'][1] * 255)}, {int(item['fill'][2] * 255)})" if item['fill'] else 'none'
                fill_opacity = item['fill_opacity'] if item['fill_opacity'] is not None else 1.0

                rect_element = f'''
                <rect x="{x}" y="{y}" width="{width}" height="{height}"
                    stroke="{stroke_color}"
                    stroke-width="{stroke_width}"
                    stroke-opacity="{stroke_opacity}"
                    fill="{fill_color}"
                    fill-opacity="{fill_opacity}" />
                '''
                svg_elements.append(rect_element)

            elif item['type'] == 'e':  # Assuming 'e' stands for ellipse
                cx, cy = item['center'].x, item['center'].y
                rx, ry = item['radius'].x, item['radius'].y
                stroke_color = f"rgb({int(item['color'][0] * 255)}, {int(item['color'][1] * 255)}, {int(item['color'][2] * 255)})"
                stroke_width = item['width']
                stroke_opacity = item['stroke_opacity']
                fill_color = f"rgb({int(item['fill'][0] * 255)}, {int(item['fill'][1] * 255)}, {int(item['fill'][2] * 255)})" if item['fill'] else 'none'
                fill_opacity = item['fill_opacity'] if item['fill_opacity'] is not None else 1.0

                ellipse_element = f'''
                <ellipse cx="{cx}" cy="{cy}" rx="{rx}" ry="{ry}"
                        stroke="{stroke_color}"
                        stroke-width="{stroke_width}"
                        stroke-opacity="{stroke_opacity}"
                        fill="{fill_color}"
                        fill-opacity="{fill_opacity}" />
                '''
                svg_elements.append(ellipse_element)

            elif item['type'] == 'p':  # Assuming 'p' stands for polygon or path
                path_data = []
                for action, *points in item['items']:
                    if action == 'M':  # Move to
                        x, y = points[0].x, points[0].y
                        path_data.append(f"M {x} {y}")
                    elif action == 'L':  # Line to
                        x, y = points[0].x, points[0].y
                        path_data.append(f"L {x} {y}")
                    elif action == 'C':  # Cubic Bezier curve
                        x1, y1 = points[0].x, points[0].y
                        x2, y2 = points[1].x, points[1].y
                        x, y = points[2].x, points[2].y
                        path_data.append(f"C {x1} {y1}, {x2} {y2}, {x} {y}")
                    elif action == 'Z':  # Close path
                        path_data.append("Z")

                stroke_color = f"rgb({int(item['color'][0] * 255)}, {int(item['color'][1] * 255)}, {int(item['color'][2] * 255)})"
                stroke_width = item['width']
                stroke_opacity = item['stroke_opacity']
                fill_color = f"rgb({int(item['fill'][0] * 255)}, {int(item['fill'][1] * 255)}, {int(item['fill'][2] * 255)})" if item['fill'] else 'none'
                fill_opacity = item['fill_opacity'] if item['fill_opacity'] is not None else 1.0

                path_element = f'''
                <path d="{' '.join(path_data)}"
                    stroke="{stroke_color}"
                    stroke-width="{stroke_width}"
                    stroke-opacity="{stroke_opacity}"
                    fill="{fill_color}"
                    fill-opacity="{fill_opacity}" />
                '''
                svg_elements.append(path_element)

        svg_content += f'''<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
            {''.join(svg_elements)}
        </svg>
        '''
        print("... contains SVG")
    return svg_content

def zip_folder_to_epub(folder_path, epub_path):
    """Zips the folder structure and creates an EPUB file."""
    epub_temp_path = epub_path + ".zip"
    with zipfile.ZipFile(epub_temp_path, 'w', zipfile.ZIP_DEFLATED) as epub_zip:
        # Add mimetype first (must be uncompressed)
        mimetype_path = os.path.join(folder_path, "mimetype")
        epub_zip.write(mimetype_path, "mimetype", compress_type=zipfile.ZIP_STORED)
        # Add the rest of the files
        for root, _, files in os.walk(folder_path):
            for file in files:
                file_path = os.path.join(root, file)
                archive_path = os.path.relpath(file_path, folder_path)
                if archive_path != "mimetype":  # mimetype already added
                    epub_zip.write(file_path, archive_path)

    # Rename the zip file to .epub
    os.rename(epub_temp_path, epub_path)
    print(f"EPUB file created at: {epub_path}")

# html version
print("Creating HTML version with selectable text")
create_epub_structure_from_pdf(pdf_path, output_folder_html,"html",True)
zip_folder_to_epub(output_folder_html, epub_file_path)

# pageimages version
print("Creating version consiting of PAGE IMAGES")
create_epub_structure_from_pdf(pdf_path, output_folder_pageimages,"pageimages",False)
zip_folder_to_epub(output_folder_pageimages, epub_file_path_pageimages)
