"""
Copyright (C) 2024 André Ourednik and Contributors

Permission is hereby granted to use this script for any purpose, including preparing production-ready documents, provided the following conditions are met:

1. You may not redistribute or sell this script or any derived software based on this script, in part or in whole, for commercial purposes without prior written permission from the original author, André Ourednik.

2. Redistribution of this script, with or without modifications, must retain this copyright notice and terms. Modifications must include a notice identifying the contributing authors and a summary of the changes made.

3. Contributors grant joint copyright ownership of their contributions to the original author (André Ourednik), ensuring that this script and all derived works remain under these terms.

4. Non-Liability: This script is provided "as is," without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose, or non-infringement. In no event shall the authors or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the script or the use or other dealings in the script.

This license does not restrict the use of outputs or products generated by this script, provided the script itself is not redistributed or sold.

Author: André Ourednik
Contributors: Bruce Keith
"""

import os
import argparse
import yaml
import zipfile
import shutil
import fitz  # PyMuPDF package for PDF processing
from PIL import Image # pillow package
import io
import json
import base64
from datetime import datetime

parser = argparse.ArgumentParser(description="Convert PDF to fixed-layout EPUB, conserving the table of contents")
parser.add_argument("--pdf_path", type=str, help="Path to the sourcePDF file")
parser.add_argument("--output_folder", type=str, help="Folder into which the resulting EPUB will be written")
parser.add_argument("--title", type=str, help="Book title")
parser.add_argument("--epub_file_name", type=str, help="Name of the EPUB file, without extension")
parser.add_argument("--author", type=str, help="Book author")
parser.add_argument("--language", type=str, help="Main book lnaguage")
parser.add_argument("--publisher", type=str, help="Book publisher")
parser.add_argument("--date", type=str, help="Publication date of the book")
parser.add_argument("--description", type=str, help="Book description")
parser.add_argument("--rights", type=str, help="Rights information of your PDF book")
parser.add_argument("--font_folder", type=str, help="Folder containing fonts")
parser.add_argument("--css_folder", type=str, help="Folder containing the css file")
parser.add_argument("--cover_image", type=str, help="Path to the cover image")
parser.add_argument("--urn", type=str, help="URN of the PDF file")
parser.add_argument("--yaml_config", type=str, help="Path to the YAML configuration file")

args = parser.parse_args()

# Initialize variables with command-line arguments or defaults
pdf_path = args.pdf_path
output_folder = args.output_folder
title = args.title
epub_file_name = args.epub_file_name
author = args.author
language = args.language
publisher = args.publisher
date = args.date
description = args.description
rights = args.rights
font_folder = args.font_folder
css_folder = args.css_folder
cover_image = args.cover_image
urn = args.urn

# Default values
defaults = {
    'output_folder' : "output",
    'title': "Default Title",
    'author': "Unknown Author",
    'language': "en",
    'publisher': "Unknown Publisher",
    'date': "2025-01-01",
    'description': "No Description",
    'rights': "All Rights Reserved",
    'font_folder': "font",
    'css_folder': "css",
    'cover_image': "",
    'urn': "urn:1234567890"
}
no_pdf_message = "A PDF filename is required and must be provided either as first argument (pdf2epub3fixed.py --pdf_path your_file.pdf) or in the YAML configuration file."

# Fallback to YAML values if yaml_config is defined, and if values not provided in command-line arguments, and to defaults if not provided in the yaml file
if args.yaml_config and os.path.isfile(args.yaml_config):
    print(f"Reading configuration file {args.yaml_config}. Parameters unspecified in the command line will be read from {args.yaml_config} whenever available")
    yaml_file = args.yaml_config
elif args.yaml_config and not os.path.isfile(args.yaml_config) :
    raise FileNotFoundError(f"The configuration file {args.yaml_config} does not exist.")
elif os.path.isfile("config.yml") :
    print("No configuration file specified in the parameters, but config.yml found. Parameters unspecified in the command line will be read from config.yml whenever available.")
    yaml_file = "config.yml"
else : yaml_file = None

if yaml_file is not None :
    with open(yaml_file, 'r') as file:
        yaml_config = yaml.safe_load(file)
    pdf_path = args.pdf_path if args.title else yaml_config.get('pdf_path')
    if not pdf_path:
            raise ValueError(no_pdf_message)
    output_folder = args.output_folder if args.output_folder else yaml_config.get('output_folder', defaults['output_folder'])
    title = args.title if args.title else yaml_config.get('title', defaults['title'])
    epub_file_name = args.epub_file_name if args.epub_file_name else yaml_config.get('epub_file_name', os.path.splitext(pdf_path)[0])
    author = args.author if args.author else yaml_config.get('author', defaults['author'])
    language = args.language if args.language else yaml_config.get('language', defaults['language'])
    publisher = args.publisher if args.publisher else yaml_config.get('publisher', defaults['publisher'])
    date = args.date if args.date else yaml_config.get('date', defaults['date'])
    description = args.description if args.description else yaml_config.get('description', defaults['description'])
    rights = args.rights if args.rights else yaml_config.get('rights', defaults['rights'])
    font_folder = args.font_folder if args.font_folder else yaml_config.get('font_folder', defaults['font_folder'])
    css_folder = args.css_folder if args.css_folder else yaml_config.get('css_folder', defaults['css_folder'])
    cover_image = args.cover_image if args.cover_image else yaml_config.get('cover_image', defaults['cover_image'])
    urn = args.urn if args.urn else yaml_config.get('urn', defaults['urn'])
else :
    # Fallback to default values if even YAML config is not provided
    if not pdf_path:
        raise ValueError(no_pdf_message)
    output_folder = output_folder if output_folder else defaults['output_folder']
    title = title if title else defaults['title']
    epub_file_name = epub_file_name if epub_file_name else os.path.splitext(pdf_path)[0]
    author = author if author else defaults['author']
    language = language if language else defaults['language']
    publisher = publisher if publisher else defaults['publisher']
    date = date if date else defaults['date']
    description = description if description else defaults['description']
    rights = rights if rights else defaults['rights']
    font_folder = font_folder if font_folder else defaults['font_folder']
    css_folder = css_folder if css_folder else defaults['css_folder']
    cover_image = cover_image if cover_image else defaults['cover_image']

output_folder_html = os.path.join(output_folder,epub_file_name + "_html")
epub_file_path = os.path.join(output_folder,epub_file_name)

def int_to_hex_color(value):
    return f"#{value:06X}"

def write_mimetype_file(output_folder):
    mimetype_path = os.path.join(output_folder, "mimetype")
    with open(mimetype_path, "w", encoding="utf-8") as f:
        f.write("application/epub+zip")

def generate_font_list(folder_path):
    font_array = []
    for file_name in os.listdir(folder_path):
        if file_name.endswith((".ttf", ".otf")):  # Check if the file is a TrueType font
            font_name = os.path.splitext(file_name)[0]  # Remove the '.ttf' extension
            font_path = os.path.join(folder_path, file_name)
            font_array.append({
                "font_name": font_name,
                "font_path": font_path
            })
    return font_array

font_list = generate_font_list(font_folder)
fonts_in_pdf = []

def write_meta_inf_container_xml(meta_inf_folder):
    """Write the META-INF/container.xml file"""
    container_path = os.path.join(meta_inf_folder, "container.xml")
    container_content = """<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
    <rootfiles>
        <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
    </rootfiles>
</container>
"""
    with open(container_path, "w", encoding="utf-8") as f:
        f.write(container_content)

def write_content_opf(oebps_folder,content_opf_items,page_html_files,variant):
    """Write OEBPS/content.opf"""
    content_opf_path = os.path.join(oebps_folder, "content.opf")
    font_items = ""
    if variant == "html" :
        for font in font_list:
            media_type = "application/x-font-ttf"  # Default for .ttf
            if font["font_path"].lower().endswith(".otf"):
                media_type = "application/vnd.ms-opentype"  # Correct media type for .otf
            font_items += f'<item id="{font["font_name"]}" href="{font["font_path"]}" media-type="{media_type}"/>\n'    
    content_opf_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<package version="3.0" xmlns="http://www.idpf.org/2007/opf" unique-identifier="bookid" prefix="rendition: http://www.idpf.org/vocab/rendition/# ibooks: http://vocabulary.itunes.apple.com/rdf/ibooks/vocabulary-extensions-1.0/"  xml:lang="{language}">
    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
        <meta name="generator" content="pdf2epub3fixed-mod" />
        <meta property="ibooks:specified-fonts">true</meta>
        <dc:title>{title}</dc:title>
        <dc:creator id="creator">{author}</dc:creator>
        <meta refines="#creator" property="role" scheme="marc:relators">aut</meta>
        <dc:identifier id="bookid">urn:isbn:{urn}</dc:identifier>
        <dc:publisher>{publisher}</dc:publisher>
        <dc:language>{language}</dc:language>
        <dc:date>{date}</dc:date>
        <dc:rights>{rights}</dc:rights>
        <dc:description>{description}</dc:description>
        <meta property="dcterms:modified">{datetime.now().strftime('%Y-%m-%dT%H:%M:%SZ')}</meta>
        <meta name="cover" content="book-cover" />
        <!--fixed-layout options-->
		<meta property="rendition:layout">pre-paginated</meta>
		<meta property="rendition:orientation">portrait</meta>
		<meta property="rendition:spread">none</meta>
        <!--a11y options-->
        <meta property="schema:accessibilitySummary">This publication conforms to WCAG 2.0 Level A.</meta>
        <meta property="schema:accessModeSufficient">visual</meta>
        <meta property="schema:accessibilityFeature">alternativeText</meta>
        <meta property="schema:accessibilityFeature">highContrastDisplay</meta>
        <meta property="schema:accessibilityFeature">readingOrder</meta>
        <meta property="schema:accessibilityFeature">structuralNavigation</meta>
        <meta property="schema:accessibilityFeature">pageNavigation</meta>
        <meta property="schema:accessibilityFeature">pageBreakMarkers</meta>
        <meta property="schema:accessibilityFeature">tableOfContents</meta>
        <meta property="schema:accessMode">textual</meta>
        <meta property="schema:accessMode">visual</meta>
        <meta property="schema:accessModeSufficient">textual</meta>
        <meta property="schema:accessModeSufficient">visual</meta>
        <meta property="schema:accessibilityHazard">none</meta>
    </metadata>
    <manifest>
        <item id="toc" href="toc.ncx" media-type="application/x-dtbncx+xml"/>
        <item id="nav" href="toc.xhtml" media-type="application/xhtml+xml" properties="nav"/>
        <item id="css" href="{css_folder}/style.css" media-type="text/css"/>
        {font_items}
        {"".join(content_opf_items)}
    </manifest>
    <spine toc="toc">
        {"".join(page_html_files)}
    </spine>
</package>
"""
    with open(content_opf_path, "w", encoding="utf-8") as f:
        f.write(content_opf_content)

def write_toc_xhtml(oebps_folder, doc):
    """This generates an EPUB 3 type navigation."""
    toc_xhtml_path = os.path.join(oebps_folder, "toc.xhtml")
    toc = doc.get_toc() # [[1, 'Préface', 7], [1, 'Les deux mélodies fondamentales', 17], ...]
    toc_xhtml_points = []
    for chapnum, t in enumerate(toc) :
        toc_xhtml_points.append(f"""
        <li><a href="page_{t[2]}.xhtml">{t[1]}</a></li>
        """)
    toc_xhtml_content = f"""<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="{language}" xml:lang="{language}">
    <head>
        <title>Table of Contents</title>
    </head>
    <body>
        <nav id="toc" epub:type="toc" role="doc-toc" aria-labelledby="nav_contents">
            <h1 id="nav_contents">Contents</h1>
            <ol>
                {"".join(toc_xhtml_points)}
            </ol>
        </nav>
        <nav id="landmarks" epub:type="landmarks" aria-labelledby="nav_landmarks">
        <h1 id="nav_landmarks">Landmarks</h1>
        <ol>
            <li><a epub:type="cover" href="page_1.xhtml">Cover</a></li>
            <li><a epub:type="bodymatter" href="page_2.xhtml">{title}</a></li>
    </ol>
    </nav>
    </body>
</html>
"""
    with open(toc_xhtml_path, "w", encoding="utf-8") as f:
        f.write(toc_xhtml_content)

def write_toc_ncx(oebps_folder, doc):
    """This generates an EPUB 2 type navigation. Deprecated."""
    toc_ncx_path = os.path.join(oebps_folder, "toc.ncx")
    toc = doc.get_toc() # [[1, 'Préface', 7], [1, 'Les deux mélodies fondamentales', 17], ...]
    toc_ncx_points = []
    for chapnum, t in enumerate(toc) :
        toc_ncx_points.append(f"""
        <navPoint id="chapter-{chapnum + 1}" playOrder="{chapnum + 1}">
            <navLabel>
                <text>{t[1]}</text>
            </navLabel>
            <content src="page_{t[2]}.xhtml"/>
        </navPoint>
        """)
    toc_ncx_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
    <head>
        <meta name="dtb:uid" content="urn:isbn:{urn}"/>
        <meta name="dtb:depth" content="1"/>
        <meta name="dtb:totalPageCount" content="{doc.page_count}"/>
        <meta name="dtb:maxPageNumber" content="{doc.page_count}"/>
    </head>
    <docTitle>
        <text>{title}</text>
    </docTitle>
    <navMap>
        {"".join(toc_ncx_points)}
    </navMap>
</ncx>
"""
    with open(toc_ncx_path, "w", encoding="utf-8") as f:
        f.write(toc_ncx_content)

def write_css_and_font_files(oebps_folder,font_folder_output,variant):
        # Step 8: Add a CSS file with @font-face
    css_folder = os.path.join(oebps_folder, "css")
    os.makedirs(css_folder, exist_ok=True)  # Create the 'css' folder if it doesn't exist
    css_path = os.path.join(css_folder, "style.css")
    css_content = ""
    if variant == "html" :
        for font in font_list :
            original_extension = os.path.splitext(font['font_path'])[1]
            output_filename_css = f"{font['font_name']}{original_extension}" # Path in CSS
            css_content += f"""@font-face {{
        font-family: \"{font['font_name']}\";
        font-style: normal;
        font-weight: normal;
        src: url(\"../font/{output_filename_css}\");
    }}"""
    css_content += """body, div, dl, dt, dd, h1, h2, h3, h4, h5, h6, p, pre, code, blockquote, figure {
	margin:0;
	padding:0;
	border-width:0;
	text-rendering:optimizeSpeed;
}
div { position: absolute; }
img { position: absolute; }
"""
    with open(css_path, "w", encoding="utf-8") as f:
        f.write(css_content)
    if variant == "html" :
        for font in font_list : 
            original_extension = os.path.splitext(font['font_path'])[1]  # Get the original extension (.ttf or .otf)
            output_filename = f"{font['font_name']}{original_extension}"
            font_path_output = os.path.join(font_folder_output, output_filename)
            shutil.copyfile(font['font_path'], font_path_output)

def extract_pdf_to_json(doc, output_json_path):
    """Extracts all pages of a PDF as JSON and writes to a file."""
    pages_data = []
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        page_dict = page.get_text("dict")  # Extract page data in dict format        
        # Process blocks to handle binary data
        for block in page_dict.get("blocks", []):
            if "image" in block and isinstance(block["image"], bytes):
                # Convert image bytes to base64 string
                block["image"] = base64.b64encode(block["image"]).decode("utf-8")
        page_data = {
            "page_num": page_num + 1,  # Human-readable page number
            "content": page_dict,
        }
        pages_data.append(page_data)
    with open(output_json_path, "w", encoding="utf-8") as json_file:
        json.dump(pages_data, json_file, indent=4, ensure_ascii=False)
    print(f"PDF content extracted and saved to {output_json_path}")

def create_epub_structure_from_pdf(pdf_path, output_folder, variant, generate_json = True):    
    """Creates the folder structure and files needed for a fixed-layout EPUB from a PDF. Generates a HTML based version with selectable text and single background image"""
    os.makedirs(output_folder, exist_ok=True)
    meta_inf_folder = os.path.join(output_folder, "META-INF")
    os.makedirs(meta_inf_folder, exist_ok=True)
    oebps_folder = os.path.join(output_folder, "OEBPS")
    os.makedirs(oebps_folder, exist_ok=True)

    font_folder_output = os.path.join(oebps_folder, "font")
    os.makedirs(font_folder_output, exist_ok=True)

    images_folder = os.path.join(oebps_folder, "image")
    os.makedirs(images_folder, exist_ok=True)
    write_mimetype_file(output_folder)
    write_meta_inf_container_xml(meta_inf_folder)

    # Initialize content.opf and toc.ncx content
    content_opf_items = []
    page_html_files = []

    # Loop through PDF pages and generate HTML
    doc = fitz.open(pdf_path)
    if generate_json : 
        print("Extracting the PDF structure as raw JSON data for verification")
        extract_pdf_to_json(
            doc,
            os.path.join(output_folder, epub_file_name + "_rawstructure.json")
        )
    image_counter = 0
    print("processing pages: ")
    for page_num in range(doc.page_count):
        print(str(page_num), end="\r")
        print(str(page_num), end=" ")
        page = doc.load_page(page_num)
        html_file_name = f"page_{page_num + 1}.xhtml"
        html_file_path = os.path.join(oebps_folder, html_file_name)
        # Generate fixed-layout HTML for the page
        if variant == "html" :
            page_html, image_counter, image_manifest = generate_fixed_layout_html_selectable(
                page, page_num, images_folder, image_counter
            )

        with open(html_file_path, "w", encoding="utf-8") as f:
            f.write(page_html)
        # Add to manifest and toc
        content_opf_items.append(
            f'<item id="page_{page_num + 1}" href="{html_file_name}" media-type="application/xhtml+xml"/>\n'
        )
        for img in image_manifest:
            content_opf_items.append(
                f'<item id="page_{img["id"]}" href="{img["href"]}" media-type="image/jpeg"/>\n'
            )
        page_html_files.append(f'<itemref idref="page_{page_num + 1}"/>\n')
    print("pages processed.")

    # Add a cover image if available  
    if os.path.exists(cover_image) :
        print("Processing cover image")
        cover_image_destination = os.path.join(images_folder, cover_image)
        shutil.copy2(cover_image, cover_image_destination)
        content_opf_items.append(
                f'<item id="book-cover" href="image/{cover_image}" media-type="image/jpeg"/>\n'
            )
    else : print("Your book has no cover image.")

    if variant == "html":
        print("\nVerify if you have all the fonts actually used in the PDF. Add them if necessary, using these exact names:")
        for fnt in fonts_in_pdf:
            print(fnt)
    write_content_opf(oebps_folder,content_opf_items,page_html_files,variant)
    write_toc_xhtml(oebps_folder, doc)
    write_toc_ncx(oebps_folder, doc)
    write_css_and_font_files(oebps_folder,font_folder_output,variant)
    print(f"\nEPUB structure created at: {output_folder}")

def is_all_caps(text):
  """
  Checks if the given text is entirely in uppercase. There is no way to extract smallcaps status from pdf, so using this as fallback 
  """
  for char in text:
    if not char.isalpha() or not char.isupper() or char in ["."," ",","]:
      return False
  return True

def generate_fixed_layout_html_selectable(page, page_num, images_folder, image_counter, dpi=300):
    """Generates fixed-layout HTML with selectable text for a single PDF page. Now renders background image for use in picture books. Also renders complete sentences without spans or divs."""
    page_width = page.rect.width
    page_height = page.rect.height
    html_content = f"""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="{language}" xml:lang="{language}">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width={page_width},height={page_height}" />
    <title>Page {page_num + 1}</title>
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <style>
        body {{
            width: {page_width}px;
            height: {page_height}px;
            position: relative;
            overflow: hidden; /* Prevent text outside page bounds from being visible */
        }}
        div {{
            position: absolute;
            white-space: pre; /* Preserve whitespace */
            -webkit-user-select: text; /* Enable text selection for webkit browsers */
            -moz-user-select: text;    /* Enable text selection for Firefox */
            -ms-user-select: text;     /* Enable text selection for IE/Edge */
            user-select: text;         /* Standard property */
            overflow: visible; /* Ensure text is visible even if it slightly overflows its container */
        }}
    </style>
</head>
<body style="width:{page_width}px;height:{page_height}px; position:relative; overflow: hidden;">
<span epub:type="pagebreak" id="page{page_num}" role="doc-pagebreak" aria-label="Page {page_num}." />
"""

    # Render the PDF page as a background image
    # pix = page.get_pixmap(dpi=dpi)
    image_filename = f"page_{page_num + 1}.jpg"
    # image_path = os.path.join(images_folder, image_filename)
    # pix.save(image_path, "jpeg")
    html_content += f'<img alt="ALT_TEXT_HERE" src="image/{image_filename}" style="position:absolute; left:0px; top:0px; width:{page_width}px; height:{page_height}px; z-index: -1;" />\n'

    text_instances = page.get_text("dict")
    if "blocks" in text_instances:
        for block in text_instances["blocks"]:
            if "lines" in block:
                for line in block.get('lines', []):
                    for span in line.get('spans', []):
                        font_name = span["font"]
                        if font_name not in fonts_in_pdf:
                            fonts_in_pdf.append(font_name)
                        if 'text' in span:
                            left = span['origin'][0]
                            top = span['origin'][1]
                            size = span['size']
                            font = span['font']
                            text = span['text']
                            color = span['color']
                            
                            if int(color) != 0:
                                hex_color = int_to_hex_color(int(color))
                                text_color = f" color:{hex_color};"
                            else: 
                                text_color = ""
                            
                            if is_all_caps(text):
                                html_content += f'<div style="left:{left:.2f}px; top:{top:.2f}px; font-size:{size:.2f}px; font-family:\'{font}\'; font-variant: small-caps;"><p>{text}</p></div>\n'
                            else:
                                html_content += f'<div style="left:{left:.2f}px; top:{top:.2f}px; font-size:{size:.2f}px; font-family:\'{font}\';{text_color}"><p>{text}</p></div>\n'

    # html_content = process_red_boxes_links(page, html_content)
    html_content += "</body></html>"

    image_manifest = [{
        'id': f"image_{image_counter}",
        'href': f"image/{image_filename}"
    }]
    image_counter += 1
    # html_content, image_manifest, image_counter = process_images(pdf_path, images_folder, image_counter, html_content)
    return html_content, image_counter, image_manifest

def process_images(pdf_path, output_folder_html):
    
    image_path = os.path.join(output_folder_html,"OEBPS/image")
    
    """Process images on the page and prepare the listing of images in the manifest. Only used in compelx HTML layout"""
    
    doc = fitz.open(pdf_path)

    for page_index in range(len(doc)):
        page = doc[page_index]
        images = page.get_images(full=True)
        for img_index, img in enumerate(images):
            xref = img[0]

            pix = fitz.Pixmap(doc, xref)
            if pix.colorspace.n == 4:  # Check if it's CMYK
                pix = fitz.Pixmap(fitz.csRGB, pix)  # Convert to RGB

            image = Image.open(io.BytesIO(pix.tobytes()))
            image = image.convert("RGB") # Ensure PIL also treats it as RGB
            image.save(f"{image_path}/page_{page_index+1}.jpg", "JPEG")

            # Clean up the Pixmap object
            pix = None

    doc.close()

def zip_folder_to_epub(folder_path, epub_path):
    """Zips the folder structure and creates an EPUB file."""
    epub_temp_path = epub_path + ".zip"
    with zipfile.ZipFile(epub_temp_path, 'w', zipfile.ZIP_DEFLATED) as epub_zip:
        # Add mimetype first (must be uncompressed)
        mimetype_path = os.path.join(folder_path, "mimetype")
        epub_zip.write(mimetype_path, "mimetype", compress_type=zipfile.ZIP_STORED)
        # Add the rest of the files
        for root, _, files in os.walk(folder_path):
            for file in files:
                file_path = os.path.join(root, file)
                archive_path = os.path.relpath(file_path, folder_path)
                if archive_path != "mimetype":  # mimetype already added
                    epub_zip.write(file_path, archive_path)

    # Rename the zip file to .epub
    os.rename(epub_temp_path, epub_path)
    print(f"\nEPUB file created at: {epub_path}\n")

# Output html version
print("Creating HTML version with selectable text")
create_epub_structure_from_pdf(pdf_path, output_folder_html,"html",False)
process_images(pdf_path,output_folder_html)
zip_folder_to_epub(output_folder_html, epub_file_path)
